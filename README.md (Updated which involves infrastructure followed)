# DevOps Assignment

This project consists of a FastAPI backend and a Next.js frontend that communicates with the backend.

## Project Structure

```
.
├── backend/               # FastAPI backend
│   ├── app/
│   │   └── main.py       # Main FastAPI application
│   └── requirements.txt    # Python dependencies
└── frontend/              # Next.js frontend
    ├── pages/
    │   └── index.js     # Main page
    ├── public/            # Static files
    └── package.json       # Node.js dependencies
```

## Prerequisites

- Python 3.8+
- Node.js 16+
- npm or yarn

## Backend Setup

1. Navigate to the backend directory:
   ```bash
   cd backend
   ```

2. Create a virtual environment (recommended):
   ```bash
   python -m venv venv
   source venv/bin/activate  # On Windows: .\venv\Scripts\activate
   ```

3. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```

4. Run the FastAPI server:
   ```bash
   uvicorn app.main:app --reload --port 8000
   ```

   The backend will be available at `http://localhost:8000`

## Frontend Setup

1. Navigate to the frontend directory:
   ```bash
   cd frontend
   ```

2. Install dependencies:
   ```bash
   npm install
   # or
   yarn
   ```

3. Configure the backend URL (if different from default):
   - Open `.env.local`
   - Update `NEXT_PUBLIC_API_URL` with your backend URL
   - Example: `NEXT_PUBLIC_API_URL=https://your-backend-url.com`

4. Run the development server:
   ```bash
   npm run dev
   # or
   yarn dev
   ```

   The frontend will be available at `http://localhost:3000`

## Changing the Backend URL

To change the backend URL that the frontend connects to:

1. Open the `.env.local` file in the frontend directory
2. Update the `NEXT_PUBLIC_API_URL` variable with your new backend URL
3. Save the file
4. Restart the Next.js development server for changes to take effect

Example:
```
NEXT_PUBLIC_API_URL=https://your-new-backend-url.com
```

## For deployment:
   ```bash
   npm run build
   # or
   yarn build
   ```

   AND

   ```bash
   npm run start
   # or
   yarn start
   ```

   The frontend will be available at `http://localhost:3000`

## Testing the Integration

1. Ensure both backend and frontend servers are running
2. Open the frontend in your browser (default: http://localhost:3000)
3. If everything is working correctly, you should see:
   - A status message indicating the backend is connected
   - The message from the backend: "You've successfully integrated the backend!"
   - The current backend URL being used

## API Endpoints

- `GET /api/health`: Health check endpoint
# DevOps Assignment – Production Infrastructure Implementation

## Repository Information

This repository is a fork of the original PG-AGI DevOps Assignment repository.

All infrastructure, CI/CD, and deployment work has been implemented in this fork while preserving the complete Git history, as required.

Original Repository:  
https://github.com/PG-AGI/DevOps-Assignment

---

# 1. Project Overview

This project focuses on designing, deploying, and operating production-grade infrastructure for a simple frontend–backend application.

The application itself is intentionally minimal:

## Backend Endpoints

- `GET /api/health` → Health check  
- `GET /api/message` → Integration confirmation  

The core focus of this implementation is:

- Infrastructure design
- Environment separation
- Security and networking decisions
- CI/CD automation
- Infrastructure as Code (Terraform)
- Operational thinking

---

# 2. Current Implementation Scope

## Cloud Provider Implemented

- Amazon Web Services (AWS)

## Infrastructure Created

- EC2 Instance 1 → Terraform Execution Node
- EC2 Instance 2 → Jenkins CI/CD Server
- Dockerized Frontend
- Dockerized Backend
- Docker Compose-based deployment
- Basic CI/CD pipeline (Jenkins)
- Secure SSH key-based access

---

# 3. High-Level Architecture

GitHub (Forked Repository)
        │
        ▼
Jenkins EC2 (CI/CD)
        │
        ▼
Docker Build & Docker Compose Deployment
        │
        ▼
Frontend + Backend Containers

Terraform EC2 (Infrastructure Control Plane)
        │
        ▼
AWS Infrastructure Provisioning

---

# 4. Why Two Separate EC2 Instances?

## 4.1 Terraform EC2 (Infrastructure Node)

Purpose:
- Runs Terraform
- Provisions AWS infrastructure
- Maintains Terraform state
- Isolated infrastructure management

Reasoning:
- Clear separation of responsibilities
- Prevents CI/CD jobs from modifying infrastructure accidentally
- Better state control
- Easier debugging
- Production-grade operational discipline

---

## 4.2 Jenkins EC2 (CI/CD Node)

Purpose:
- Pulls latest code from GitHub fork
- Builds Docker images
- Runs Docker Compose
- Automates deployments

Reasoning:
- Dedicated CI server
- Independent scaling capability
- Clean separation between infra and app deployment
- Aligns with real-world DevOps workflows

---

# 5. Compute & Runtime Decisions

Decision: EC2 + Docker (No Kubernetes)

Justification:

- Application is simple
- No orchestration complexity required
- Lower cost
- Faster implementation
- Easier troubleshooting
- Kubernetes would introduce unnecessary operational overhead

Kubernetes was intentionally avoided due to lack of strong architectural need.

---

# 6. Networking & Traffic Flow

## Public Components

- Jenkins EC2 (Port 8080)
- Application EC2 (Application ports exposed)

## Security Group Rules

Inbound:
- 22 → SSH (restricted)
- 8080 → Jenkins
- Application port → Frontend
- Backend accessible internally via Docker network

Outbound:
- Open for updates and Docker image pulls

## Frontend → Backend Communication

- Uses Docker internal networking
- Backend service reachable via Docker Compose service name

## Ingress Strategy

- Direct EC2 Public IP access (current stage)
- Reverse proxy not yet implemented

---

# 7. Dockerization

Both services are containerized:

- Backend → Python-based container
- Frontend → Node-based container
- Docker Compose → Multi-container orchestration

Benefits:
- Environment consistency
- Portable deployments
- CI/CD integration
- Easy rebuild and restart

---

# 8. CI/CD Pipeline (Jenkins)

## Pipeline Flow

1. Pull latest code from GitHub fork
2. Build Docker images
3. Execute `docker compose up -d`
4. Restart containers if required

## Deployment Strategy

- Containers recreated during deployment
- Short downtime acceptable (simple application)

## Rollback Strategy

- Rebuild and redeploy previous commit
- Future improvement: Version-tagged Docker images

---

# 9. Infrastructure as Code (Terraform)

Terraform is used to:

- Provision EC2 instances
- Configure security groups
- Define infrastructure declaratively

## State Management

- Currently using local state on Terraform EC2
- Isolated from Jenkins
- Future enhancement: Remote backend (S3 + DynamoDB locking)

## Why State Isolation Matters

- Prevents state corruption
- Avoids parallel execution conflicts
- Improves recovery capability

---

# 10. Environment Strategy

Planned Environments:

- dev
- staging
- prod

Current Status:

- dev implemented

Future differentiation:

- Instance size scaling
- Resource allocation differences
- Manual approval for production deployments
- Deployment protection policies

---

# 11. Scalability & Availability

Current Setup:

- Single EC2 per role
- Manual scaling
- Restartable Docker containers

Not Yet Implemented:

- Auto Scaling Groups
- Load Balancer
- Multi-AZ deployment

Minimum Availability:

- Depends on EC2 uptime
- Manual recovery required in case of instance failure

---

# 12. Security & Identity

Implemented:

- SSH key-based access
- No secrets stored in Git
- No credentials inside Docker images
- Jenkins secured with authentication

Not Yet Implemented:

- IAM least-privilege roles
- Secrets Manager integration
- HTTPS with SSL
- WAF or advanced security layers

---

# 13. Failure & Operational Thinking

## Smallest Failure Unit

- Docker container

## Failure Scenarios

If container crashes:
- Can be restarted via Docker

If EC2 crashes:
- Entire service unavailable
- Manual recovery required

## Alerting

- Not implemented yet
- Planned: CloudWatch alarms

## 2 AM Wake-Up Scenarios

- EC2 instance down
- Jenkins pipeline failure blocking production deployment

---

# 14. Future Growth (10× Traffic Scenario)

Required Changes:

- Introduce Application Load Balancer
- Implement Auto Scaling Groups
- Separate frontend and backend instances
- Introduce managed database (if required)
- Remote Terraform backend (S3 + DynamoDB)
- Blue/Green deployment strategy

What Remains Unchanged:

- Dockerization approach
- CI/CD workflow structure
- Infrastructure as Code strategy

Early Good Decisions:

- Separation of Terraform and Jenkins
- Containerization
- Infrastructure defined as code

---

# 15. What We Did NOT Do (Intentional Decisions)

- Did not use Kubernetes (over-engineering for current scope)
- Did not implement Load Balancer yet
- Did not configure Auto Scaling
- Did not implement HTTPS
- Did not configure centralized monitoring
- Did not move Terraform state to S3 backend yet
- Did not complete second cloud provider deployment yet

Reason:

Focused on building a strong, clean, foundational infrastructure before adding complexity.

---

# 16. How to Run Locally

## Clone Repository

```bash
git clone <your-fork-url>
cd DevOps-Assignment
```

## Build and Run

```bash
docker compose build
docker compose up -d
```

## Test Backend

```
http://localhost:<backend-port>/api/health
```

## Access Frontend

```
http://localhost:<frontend-port>
```

---

# 17. Hosted URLs

Frontend:
http://13.232.246.116:3000/

Backend:
http://13.232.246.116:8000/api/health
http://13.232.246.116:8000/docs

Jenkins:
http://3.110.130.61:3000/
http://3.110.130.61:8000/api/health
http://3.110.130.61:8000/docs

---

# 18. External Architecture Documentation

Google Docs Link:
https://docs.google.com/document/d/1OGMwhLVx3sOZOMKEGLvza9COUSm3a53pmrdP6MgjhSA/edit?usp=sharing

This document includes:

- Cloud & region selection reasoning
- Architecture diagrams
- Networking & security design
- Scalability strategy
- State management explanation
- Failure scenarios
- Future growth planning
- Tradeoff analysis

---

# 19. Demo Video

https://drive.google.com/file/d/1bZO1pE0eGuXk489rXWGRVOBKUbH9YLCs/view?usp=sharing

Video includes:

- Architecture walkthrough
- Terraform explanation
- Jenkins CI/CD demo
- Deployment flow
- Tradeoffs and limitations
- Future growth discussion

---

# 20. Final Notes

This implementation prioritizes:

- Clear separation of responsibilities
- Infrastructure reproducibility
- Incremental scalability
- Practical production thinking over unnecessary tool complexity

The design intentionally focuses on strong fundamentals rather than excessive tooling.
  - Returns: `{"status": "healthy", "message": "Backend is running successfully"}`

- `GET /api/message`: Get the integration message
  - Returns: `{"message": "You've successfully integrated the backend!"}`
